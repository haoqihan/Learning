### 面对对象的定义

**class 类名** (类名首字母大写) 

**类:**具有相同属性和技能的一类事物 

**对象:**类的具体表现 

**实例化**

- 由一个类创建一个对象的过程 
- 详细过程 
	- 1,类名() 执行 __ new __ 方法,先从自己的类中寻找,如果没有找到,则从父类(直到object类)寻找,然后从object的 __ new __产生一个对象空间,返回给类名(). 
	- 2,对象空间一旦产生并返回.则自动执行__ init __方法,给这个对象空间封装属性. 
	- 最终你得到是封装好属性的对象空间. 

**基础操作**

**类**

- **类名.属性:**可以对类里的属性进行增删改查 
- **类名.方法名**(self:self可以随意参数):调用类里面的方法 

**对象(也可以作为一个方法的参数)**

- **对象名.属性**:可以对自己空间里的属性进行增删改查,不能对类里面的静态属性进行删改 
- **对象名.方法**:可以调用类里面的方法 

### 面对对象VS面对过程

**面对过程**

- **优点**：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可 
- **缺点**：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。 

**面对对象**

- **优点：**解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易 
- **缺点**：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。 

### 类的相关知识

**声明类**:class 类名（类名的首字母需要大写） 

**类的属性,方法和实例化**

- **属性**：类名.静态字段：这个静态字段就是属性 
- **方法**：类名.函数名：这个函数名就是方法 
- **实例化**：类名加括号就是实例化，会自动触发__init__函数的运行，可以用它来为每个实例定制自己的特征 

**类的基本属性**

- 类名.__ dict __:查出来的是一个字典，key是属性，value为值 
- 类名.__ name __# 类的名字(字符串)
- 类名.__ doc __# 类的文档字符串
- 类名.__ base __# 类的第一个父类
- 类名.__ bases __# 类所有父类构成的元组
- 类名.__ dict __# 类的字典属性
- 类名.__ module __# 类定义所在的模块
- 类名.__ class __# 实例对应的类(仅新式类中)

### **类的整体分类**

**查看对象或类中所有的方法和属性** 

- 类名.__ dect __
- 对象名.__ dect __

**第一部分:静态字段** 

- 1.公有静态字段
- 2.私有静态字段

**第二部分 属性,方法(函数)** 

- **普通方法**(def func(self)) 

- **私有方法**(def __func(self)) 

- **类方法**

	- @classmethod类方法装饰器  
		- 类名调用类方法,自动将类的空间传给类中的cls 

- **静态方法**

	- @staticmethod静态方法装饰器 
		- 在类中定义一个静态方法,无需传入你的类空间,对象空间,可以当成普通函数使用 

	

- **属性方法**

	- @pyperty 把一个方法变成属性 
		- 将方法伪装成属性,虽然在代码层面没有任何高深之处,但是可以让其看起来更合理一些 
		- **改**
			- @函数名.setter
			- 只要触发 '=' 条件时就会执行它下面的函数
		- **删**
			- @函数名.deleter
			- 当触发删除条件,运行这个下面的函数

**为什么要设置私有成员**

- 有些变量,方法,属性,只在类内部进行使用即可,不便于(不允许)类外部或派生类中使用 

### 类名称空间和对象名称空间

**类里可以定义两种属性**

- **静态属性**:就是直接在类中定义的变量 
- **动态属性**:定义在类中的方法 

**类名称空间**:只要定义了一个类,那么里面所有的内容会全部储存在空间里,其中类的数据是共享给所有对象的 

**对象名称空间**:它的第一步数先建立一个空的空间,然后里面的第一个内容,其实是类对象指针,然后才是其他的内容一步一步的传入的 

### 类的三大特性

- **封装**
	- **封装**就是将一些属性或者方法(有用的信息)放置在一个空间中,最好不要改变 
	- 给对象封装属性
	- 给类封装属性
	- **私有成员**:私有静态字段,私有方法,私有属性:__变量 
		- **私有成员**:类只要加载到内存,她就会将所有的私有成员变成:_类名__变量名 
		- **何处调用**:只能在类内部调用,**不能**在它的**外部**或它的**派生类**中调用 
	- **组合**
		- **组合**:给一个类的对象,封装一个属性,这个属性是另一个类的对象 
- **继承**
	- **子类:又叫派生类**
	- **定义**
		- 继承是一种创建新类的方式,子类继承父类的一切,最大的特点:1.节省代码,2.与其他类发生关联 
	- **如何查看它的父类**
		- **查看一个**
			- 类命.__ base __:会显示一个 
		- **查看全部**
			- 类名.__ bases __:显示全部 
	- 新式类与经典类的区别 
		- python3之后都是新式类,只要父类是object的都是新式类
		- 新式类是的查询方式是广度优先,经典类是深度优先
	- **单继承**
		- 只执行父类(子类和对象必须没有此变量或方法)
		- 在子类中既执行本类又执行父类的方法
			- 1.Animal.__ init __(self,name,age,sex)# 第一种 如何在子类中执行父类方法
			- 2.super().__ init __(name, age, sex) # 第二种 如何在子类中执行父类方法
			- super() = super(Animal,self)
	- **多继承**
		- **新式类:**用的查找方式是广度优先
			- **广度算法:**用最少的次数走完每一个节点,且只走一次
		- **经典类**:深度优先,一条路走到黑
	- 查看继承顺序的方法是:**类名.mro()** 
- **多态**
	- **多态**就是同一操作（方法）作用于不同的对象时，可以有不同的解释，产生不同的执行结果 

### 接口类和抽象类

**接口类**

```python
from abc import abstractmethod,ABCMeta   这里是为了实现接口类调用的模块
class Payment(metaclass=ABCMeta):   在这里声明metaclass=ABCMeta
    @abstractmethod                  然后这里一个语法糖调用abstractmethod,就声明这个类是接口类
    def pay(self,money):pass
```

抽象类

```python
import abc 利用abc模块实现抽象类
class All_file(metaclass=abc.ABCMeta):
    all_type='file'
    @abc.abstractmethod 定义抽象方法，无需实现功能
    def read(self):
        '子类必须定义读功能'
        with open('filaname') as f:
            pass
```

```python
class Txt(All_file): 子类继承抽象类，但是必须定义read和write方法
    def read(self):
        print('文本数据的读取方法')
wenbenwenjian=Txt()
print(wenbenwenjian.read())
```

### 反射

- **机制:**反射就是 通过字符串的形式,导入模块;通过字符串的形式,去模块寻找指定函数,并执行利用字符串的形式去对象(模块)中操作(增删改查),一种基于字符串的事件驱动
- **getattr(**1.对象,2.'函数或静态名(要字符串类型的)',3.没有这个函数或静态名要返回的值)
	- 得到这个对象里的属性内容
- **hasattr():**判断这个对象的函数名是否存在,
	- 判断此对象中有没有此属性有返回True,没有返回False
- **setattr()**:对这个对象设置属性
- **delattr()**:删除属性

